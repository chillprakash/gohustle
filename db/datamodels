-- Drop existing function
DROP FUNCTION IF EXISTS create_tick_tables(text, date);

-- Function to create base tables for an index
CREATE OR REPLACE FUNCTION create_tick_tables(index_name TEXT) 
RETURNS TABLE(table_name TEXT, depth_table_name TEXT, minute_view_name TEXT) AS $$
DECLARE
    _table_name TEXT;
    _depth_table_name TEXT;
    _minute_view_name TEXT;
BEGIN
    -- Generate table names
    _table_name := format('ticks_%s', lower(index_name));
    _depth_table_name := format('%s_depth', _table_name);
    _minute_view_name := format('%s_1min', _table_name);

    -- Create main tick table
    EXECUTE format('
        CREATE TABLE IF NOT EXISTS %I (
            instrument_token INTEGER NOT NULL,
            timestamp TIMESTAMPTZ NOT NULL,
            is_tradable BOOLEAN,
            is_index BOOLEAN,
            mode VARCHAR(10),
            last_price DOUBLE PRECISION,
            last_trade_time TIMESTAMPTZ,
            last_traded_quantity INTEGER,
            total_buy_quantity INTEGER,
            total_sell_quantity INTEGER,
            volume_traded INTEGER,
            total_buy INTEGER,
            total_sell INTEGER,
            average_trade_price DOUBLE PRECISION,
            oi INTEGER,
            oi_day_high INTEGER,
            oi_day_low INTEGER,
            net_change DOUBLE PRECISION,
            open_price DOUBLE PRECISION,
            high_price DOUBLE PRECISION,
            low_price DOUBLE PRECISION,
            close_price DOUBLE PRECISION,
            PRIMARY KEY (instrument_token, timestamp)
        )', _table_name);

    -- Create hypertable
    EXECUTE format('SELECT create_hypertable(%L, %L, if_not_exists => true)', 
        _table_name, 'timestamp');

    -- Create depth table
    EXECUTE format('
        CREATE TABLE IF NOT EXISTS %I (
            instrument_token INTEGER NOT NULL,
            timestamp TIMESTAMPTZ NOT NULL,
            side VARCHAR(4) NOT NULL,
            level SMALLINT NOT NULL,
            price DOUBLE PRECISION,
            quantity INTEGER,
            orders INTEGER,
            PRIMARY KEY (instrument_token, timestamp, side, level)
        )', _depth_table_name);

    -- Create hypertable for depth
    EXECUTE format('SELECT create_hypertable(%L, %L, if_not_exists => true)', 
        _depth_table_name, 'timestamp');

    -- Create indexes
    EXECUTE format('
        CREATE INDEX IF NOT EXISTS idx_%s_instrument ON %I (instrument_token);
        CREATE INDEX IF NOT EXISTS idx_%s_timestamp ON %I (timestamp DESC);
        CREATE INDEX IF NOT EXISTS idx_%s_depth_instrument ON %I (instrument_token);
        CREATE INDEX IF NOT EXISTS idx_%s_depth_timestamp ON %I (timestamp DESC)
    ', 
    lower(index_name), _table_name,
    lower(index_name), _table_name,
    lower(index_name), _depth_table_name,
    lower(index_name), _depth_table_name);

    -- Set compression policy for both tables
    EXECUTE format('
        ALTER TABLE %I SET (
            timescaledb.compress,
            timescaledb.compress_segmentby = ''instrument_token''
        )', _table_name);
    
    EXECUTE format('
        ALTER TABLE %I SET (
            timescaledb.compress,
            timescaledb.compress_segmentby = ''instrument_token,side,level''
        )', _depth_table_name);

    -- Add retention policy (90 days) for both tables
    EXECUTE format('
        SELECT add_retention_policy(%L, 
            INTERVAL ''90 days'', 
            if_not_exists => true
        )', _table_name);
    
    EXECUTE format('
        SELECT add_retention_policy(%L, 
            INTERVAL ''90 days'', 
            if_not_exists => true
        )', _depth_table_name);

    RETURN QUERY SELECT _table_name, _depth_table_name, _minute_view_name;
END;
$$ LANGUAGE plpgsql;


-- Create an instrument_expiries table
CREATE TABLE IF NOT EXISTS instrument_expiries (
    id SERIAL PRIMARY KEY,
    instrument_name VARCHAR(50) NOT NULL,
    expiry_date TIMESTAMP NOT NULL,
    created_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMPTZ DEFAULT CURRENT_TIMESTAMP,
    is_active BOOLEAN DEFAULT TRUE,
    UNIQUE(instrument_name, expiry_date)
);

-- Create indexes for better query performance
CREATE INDEX idx_instrument_expiries_name ON instrument_expiries(instrument_name);
CREATE INDEX idx_instrument_expiries_date ON instrument_expiries(expiry_date);
CREATE INDEX idx_instrument_expiries_active ON instrument_expiries(is_active);


-- Create access_tokens table
CREATE TABLE access_tokens (
    id SERIAL PRIMARY KEY,
    token_type VARCHAR(50) NOT NULL,
    access_token TEXT NOT NULL,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    expires_at TIMESTAMPTZ NOT NULL,
    is_active BOOLEAN DEFAULT TRUE
);

-- Create indexes for better query performance
CREATE INDEX idx_access_tokens_type_active ON access_tokens(token_type, is_active);
CREATE INDEX idx_access_tokens_expires ON access_tokens(expires_at);

-- Optional: Add a comment to the table
COMMENT ON TABLE access_tokens IS 'Stores access tokens for various services with expiry tracking';

-- Optional: Create a view for active tokens
CREATE VIEW active_tokens AS
SELECT * FROM access_tokens
WHERE is_active = TRUE AND expires_at > NOW();